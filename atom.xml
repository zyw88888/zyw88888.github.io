<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>指尖艺术家の博客</title>
  
  <subtitle>记录生活的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-01T02:54:15.003Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>邹裕文</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学毕业设计</title>
    <link href="http://yoursite.com/2021/06/01/%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2021/06/01/%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-06-01T02:55:08.028Z</published>
    <updated>2021-06-01T02:54:15.003Z</updated>
    
    <content type="html"><![CDATA[<p>   本设计以单片机STC89C52作为密码锁监控装置的检测和控制核心，采用矩阵键盘输入的电子密码和指纹密码解锁两种解锁方式。系统采用LCD12864液晶显示屏实时更新显示信息，并设有修改密码功能，在解锁或修改密码时如果在未确定时发现自己按错了可以进行退格或重输的操作，如果发现旁边有人看着或者不想输入密码了可以进行退出输入的操作，从一定程度上将确保安全性。测试结果表明，本系统各项功能已达到本设计的所有要求。</p><p>PCB电路图<br><img src="https://img-blog.csdnimg.cn/20210601104625872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUyMzE2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><pre><code>系统识别存储指纹信息，可通过验证过的指纹进行快速解锁。</code></pre><p>(1)系统设置6位密码，密码通过键盘输入，若密码正确，则继电器断开（锁打开）。若密码错误，蜂鸣器报警提示。<br>(2)密码可通过按键重新设置，在设置前必须输入旧密码然后连续输入两次新密码，若输入旧密码时输错便直接退出修改密码。<br>(3)密码具有掉电保护功能，锁定后在此解除锁定的时间也具有掉电保护的功能。这样就可以防止外人或小偷输错密码后拔掉电源后再次插上电重新输入密码。<br>(4)在密码输入或重置时可退格、重输、退出输入等等操作。<br><img src="https://img-blog.csdnimg.cn/20210601104127504.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUyMzE2,size_16,color_FFFFFF,t_70#pic_center" alt="成品图"><br>       对于这次设计来说既是一次机遇，又是一次挑战。在这次的设计过程中，本人学到了很多东西，通过自己的实践，增强了动手能力。通过实际工程的设计也使我了解到书本知识和实际应用的差别。在实际应用中遇到很多的问题，这都需要我对问题进行具体的分析，并一步一步地去解决它。更多详细细节编写在毕业论文里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   本设计以单片机STC89C52作为密码锁监控装置的检测和控制核心，采用矩阵键盘输入的电子密码和指纹密码解锁两种解锁方式。系统采用LCD12864液晶显示屏实时更新显示信息，并设有修改密码功能，在解锁或修改密码时如果在未确定时发现自己按错了可以进行退格或重输的操作，如果
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2020/06/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/06/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-06-12T07:12:09.000Z</published>
    <updated>2020-06-14T07:16:27.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>   用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。</p><a id="more"></a><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h3 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h3><ol><li>灵活性、逻辑性和功能性非常的强</li><li>可以迅速地用极简单的方式达到字符串的复杂控制</li><li>对于刚接触的人来说，比较晦涩难懂</li></ol><h3 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h3><p><img src="https://img-blog.csdnimg.cn/20200614145819465.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUyMzE2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200614145837302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUyMzE2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写</td></tr><tr><td>g</td><td>全局匹配</td></tr><tr><td>gi</td><td>全局匹配+忽略大小写</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思<br>[^] 匹配除中括号以内的内容<br>\ 转义符<br>| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱<br>() 从两个直接量中选择一个，分组<br>eg：gr(a|e)y匹配gray和grey<br>[\u4e00-\u9fa5] 匹配汉字</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建正则表达式对象</span></span><br><span class="line"><span class="comment">//对象的方式创建</span></span><br><span class="line"><span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\d&#123;5&#125;/</span>);</span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"myPhoneID10086"</span>;</span><br><span class="line"><span class="comment">//调用方法验证字符串是否匹配</span></span><br><span class="line"><span class="keyword">var</span> flag=reg.test(str);</span><br><span class="line"><span class="built_in">console</span>.log(flag);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//对象的方式创建</span></span><br><span class="line"><span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\d&#123;5&#125;/</span>);</span><br><span class="line"><span class="comment">//调用方法验证字符串是否匹配</span></span><br><span class="line"><span class="keyword">var</span> flag=reg.test(<span class="string">"myPhoneID10086"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//--------------------字面量的方式创建正则表达式------------------------</span></span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/\d&#123;5&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> flag=reg.test(<span class="string">"myPhoneID10086"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;   用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS中的堆和栈及内存泄漏</title>
    <link href="http://yoursite.com/2020/05/01/JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2020/05/01/JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2020-05-01T02:10:09.000Z</published>
    <updated>2020-06-19T05:55:10.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS中的堆和栈及内存泄漏"><a href="#JS中的堆和栈及内存泄漏" class="headerlink" title="JS中的堆和栈及内存泄漏"></a>JS中的堆和栈及内存泄漏</h2><h4 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h4><blockquote><p>从电脑内存中分配一块出来，用来执行代码的内存，Stack<br>先创建变量，再做赋值操作分配一个主线程来自上而下执行。（js单线程，浏览器多线程）主要用来运行代码，和存储基本类型。</p></blockquote><p><strong>1.基本数据类型储存</strong></p><blockquote><ol><li>变量存储空间，存创建的变量  </li><li>值存储空间，存基本数据类型的值</li><li>一个值存储空间可以对应多个变量，<br>一个变量只能对应一个值存储空间。</li></ol></blockquote><p> <strong>2.说明</strong><br> 栈内存：是一个执行代码的一个空间，这个调用栈只有一个，并且大小固定，按照一定的排列规则自上而下，顺序执行。通俗点说就是先进后出</p><p><strong>3.堆栈溢出</strong><br>溢出：因为栈内存空间有限，当你执行一些递归操作没有阻断或者释放的时候，反复调用，栈内存执行序列就会排不下了。</p><h4 id="二、堆"><a href="#二、堆" class="headerlink" title="二、堆"></a>二、堆</h4><blockquote><ol><li>从内存中有拿出来一块，用来存引用数据类型<br>   Heap，一个16进制的地址。</li><li>按照键、值分别存放，并关联起来</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/20200619133937709.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUyMzE2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>引用数据类型存储</strong><br>堆内存不是有个地址么，放到栈内存的值存储空间，并和变量关联</p><h4 id="三、深拷贝和浅拷贝"><a href="#三、深拷贝和浅拷贝" class="headerlink" title="三、深拷贝和浅拷贝"></a>三、深拷贝和浅拷贝</h4><p>简单的说，浅拷贝就是只将对象 最外层 的键值复制为一个新的对象，而深拷贝则会 递归复制所有的层 ，直到该键的值为基本类型值。 再简单点说 ，经过浅拷贝后，新旧变量可能还会有所关联（既然说了是可能还有所关联，那也可能毫无关联吧，这里的关键就在于原对象的复杂程度了）；而经过深拷贝后，理论上，新旧变量再无关联。 注意 ，在进行深拷贝时，层级不宜过多。所以，一般的深拷贝也并不是绝对毫无关联的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="string">"a is a"</span>,</span><br><span class="line">arr: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;, obj1 = &#123; ...obj &#125;, <span class="comment">//假装这里是个浅拷贝</span></span><br><span class="line">obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">//假装这里是深拷贝。</span></span><br><span class="line">obj1.a = <span class="string">"value a"</span>;</span><br><span class="line">obj1.arr[<span class="number">0</span>] = <span class="number">66</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200619134027276.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUyMzE2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到，当原对象的值为 基本类型值 时，浅拷贝和深拷贝并没有区别；而当原对象的某些值为 引用类型值 时，如果修改变量的值，浅拷贝会改变原对象的值，而深拷贝则不会。</p><h4 id="四、垃圾回收"><a href="#四、垃圾回收" class="headerlink" title="四、垃圾回收"></a>四、垃圾回收</h4><p>现在浏览器基本都在使用标记-清除的算法来执行垃圾回收。而不是使用引用计数的方式，因为引用计数方式无法释放循环引用结构的内存占用。 标记清除算法的核型概念是：从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p><h4 id="五、内存泄露"><a href="#五、内存泄露" class="headerlink" title="五、内存泄露"></a>五、内存泄露</h4><blockquote><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p></blockquote><h6 id="常见的内存泄露"><a href="#常见的内存泄露" class="headerlink" title="常见的内存泄露"></a>常见的内存泄露</h6><pre><code>1. 不合理的计时器2. 被共享的闭包作用域3. 脱离dom引用4. 意外的全局变量</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS中的堆和栈及内存泄漏&quot;&gt;&lt;a href=&quot;#JS中的堆和栈及内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;JS中的堆和栈及内存泄漏&quot;&gt;&lt;/a&gt;JS中的堆和栈及内存泄漏&lt;/h2&gt;&lt;h4 id=&quot;一、栈&quot;&gt;&lt;a href=&quot;#一、栈&quot; class
      
    
    </summary>
    
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://yoursite.com/2020/03/21/%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2020/03/21/%E9%80%92%E5%BD%92/</id>
    <published>2020-03-21T01:12:09.000Z</published>
    <updated>2020-06-19T03:49:44.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识递归"><a href="#认识递归" class="headerlink" title="认识递归"></a>认识递归</h1><h2 id="一-递归："><a href="#一-递归：" class="headerlink" title="一.递归："></a>一.递归：</h2><pre><code>   满足以下三个条件就是递归                   1.函数自己调用自己                   2.一般情况下有参数                   3.一般情况下有return 【注】递归能解决循环能干的所有事，有一些循环不容易干的，递归也能轻松做到。      归的代码可以写出来，但可读性不高，不容易理解递归过程。递归的方法            1.首先找到临界值，即无需计算获得的值。            2.找到这次与上一次的关系            3.假设当前函数可以使用，调用自身计算上一次。直接上代码     计算1~n的和？</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;             </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> sum(n - <span class="number">1</span>) + n;  <span class="comment">// 找得求和规律为 sum（99）+100 =sum（100）  </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(sum(<span class="number">100</span>));  <span class="comment">//计算1~100的值为5050</span></span><br></pre></td></tr></table></figure><p>  递归sum（n）到sum（1）没算到临界值前计算机会开全部内存来计算每一个公式，当计算到临界值计算机又会依次释放掉内存。<br>  【注意】当数值十分巨大时；计算机一瞬间开大量内存，容易死机，这也是此方法的弊端。大部分公司会禁止使用递归。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识递归&quot;&gt;&lt;a href=&quot;#认识递归&quot; class=&quot;headerlink&quot; title=&quot;认识递归&quot;&gt;&lt;/a&gt;认识递归&lt;/h1&gt;&lt;h2 id=&quot;一-递归：&quot;&gt;&lt;a href=&quot;#一-递归：&quot; class=&quot;headerlink&quot; title=&quot;一.递归：&quot;&gt;
      
    
    </summary>
    
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
